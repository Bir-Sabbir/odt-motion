<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Object + Size + Motion (No Android Studio)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <!-- TensorFlow.js + COCO-SSD model -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>
  <style>
    html,body{margin:0;height:100%;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial}
    #wrap{position:fixed;inset:0;display:flex;flex-direction:column}
    #topbar{display:flex;gap:.5rem;align-items:center;padding:.5rem;background:rgba(0,0,0,.6)}
    #log{font-size:.9rem;opacity:.8;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    #stage{position:relative;flex:1;min-height:0}
    video,canvas{position:absolute;inset:0;max-width:100%;max-height:100%;width:100%;height:100%;object-fit:cover}
    button{background:#1a73e8;color:#fff;border:none;border-radius:10px;padding:.6rem 1rem;font-weight:600}
    button:disabled{opacity:.6}
    #fps{font-variant-numeric:tabular-nums;opacity:.8}
  </style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <button id="startBtn">Start camera</button>
    <span id="fps">— fps</span>
    <span id="log"></span>
  </div>
  <div id="stage">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="overlay"></canvas>
  </div>
</div>

<script>
(async function(){
  const $ = (s)=>document.querySelector(s);
  const startBtn = $('#startBtn');
  const video = $('#video');
  const canvas = $('#overlay');
  const ctx = canvas.getContext('2d');
  const fpsEl = $('#fps');
  const logEl = $('#log');

  let model = null;
  let running = false;
  let lastT = 0, frameCount = 0, lastFpsT = 0;

  // Simple tracker: assign IDs by nearest center per class
  let nextId = 1;
  const tracks = new Map(); // id -> {cls,cx,cy,t,speed}

  function matchDetections(dets) {
    // Return array of {id, det}
    const matches = [];
    const used = new Set();
    for (const det of dets) {
      const [x,y,w,h] = det.bbox;
      const cx = x + w/2, cy = y + h/2;
      let bestId = null, bestD2 = Infinity;
      for (const [id, tr] of tracks) {
        if (used.has(id)) continue;
        if (tr.cls !== det.class) continue;
        const dx = cx - tr.cx, dy = cy - tr.cy;
        const d2 = dx*dx + dy*dy;
        if (d2 < bestD2) { bestD2 = d2; bestId = id; }
      }
      if (bestId == null || bestD2 > (Math.max(w,h)*Math.max(w,h))*4) {
        const id = nextId++;
        tracks.set(id, {cls: det.class, cx, cy, t: performance.now(), speed:0});
        matches.push({id, det});
        used.add(id);
      } else {
        matches.push({id: bestId, det});
        used.add(bestId);
      }
    }
    // prune old tracks
    const now = performance.now();
    for (const [id,tr] of tracks) if (now - tr.t > 1500) tracks.delete(id);
    return matches;
  }

  function drawDetections(dets, matches) {
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    for (const {id, det} of matches) {
      const [x,y,bw,bh] = det.bbox;
      // motion estimate
      const cx = x + bw/2, cy = y + bh/2;
      const now = performance.now();
      const tr = tracks.get(id);
      let speed = 0, angDeg = 0;
      if (tr) {
        const dt = Math.max((now - tr.t)/1000, 1e-3);
        const vx = (cx - tr.cx)/dt, vy = (cy - tr.cy)/dt; // px/s in screen space
        const inst = Math.hypot(vx,vy);
        // exponential smoothing
        speed = 0.6*inst + 0.4*(tr.speed||0);
        angDeg = Math.atan2(vy,vx) * 180/Math.PI;
        Object.assign(tr, {cx,cy,t:now,speed});
      }

      // Box
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'white';
      ctx.strokeRect(x,y,bw,bh);

      // Label background
      const label = `#${id} ${det.class} ${(det.score*100).toFixed(0)}%  ${Math.round(bw)}x${Math.round(bh)}px`;
      const motion = speed>1 ? `${Math.round(speed)} px/s @ ${Math.round(angDeg)}°` : '—';
      const text = `${label}  |  ${motion}`;

      ctx.font = '16px system-ui, Segoe UI, Roboto, Arial';
      const pad = 6;
      const tw = ctx.measureText(text).width;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(x, y-22, tw+pad*2, 22);
      ctx.fillStyle = '#fff';
      ctx.fillText(text, x+pad, y-6);

      // Direction arrow
      if (speed>1) {
        const len = Math.min(60, 10 + speed*0.05);
        const ax = cx + Math.cos(angDeg*Math.PI/180)*len;
        const ay = cy + Math.sin(angDeg*Math.PI/180)*len;
        ctx.beginPath();
        ctx.moveTo(cx,cy);
        ctx.lineTo(ax,ay);
        ctx.stroke();
      }
    }
  }

  function resizeCanvasToVideo() {
    const vw = video.videoWidth || 640;
    const vh = video.videoHeight || 480;
    // set canvas to video pixels; CSS handles fit-to-screen
    if (canvas.width !== vw || canvas.height !== vh) {
      canvas.width = vw; canvas.height = vh;
    }
  }

  async function loop() {
    if (!running) return;
    if (video.readyState >= 2 && model) {
      resizeCanvasToVideo();
      const preds = await model.detect(video, 5); // top 5
      const filtered = preds.filter(p => p.score >= 0.6);
      const matches = matchDetections(filtered);
      drawDetections(filtered, matches);

      // FPS
      frameCount++;
      const now = performance.now();
      if (now - lastFpsT > 500) {
        const fps = (frameCount * 1000) / (now - lastFpsT);
        fpsEl.textContent = `${fps.toFixed(1)} fps`;
        frameCount = 0; lastFpsT = now;
      }
    }
    requestAnimationFrame(loop);
  }

  async function start() {
    startBtn.disabled = true;
    logEl.textContent = 'Loading model… (first time can take ~5–10s)';
    // Camera (rear if available)
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: 'environment' } }, audio: false
    });
    video.srcObject = stream;
    await video.play();

    // Load model
    model = await cocoSsd.load({ base: 'lite_mobilenet_v2' }); // faster on phones
    logEl.textContent = 'Model ready. Detecting…';
    running = true;
    lastFpsT = performance.now();
    loop();
  }

  if (!('mediaDevices' in navigator)) {
    logEl.textContent = 'Your browser does not support camera access.';
  }
  startBtn.addEventListener('click', start);
})();
</script>
</body>
</html>

